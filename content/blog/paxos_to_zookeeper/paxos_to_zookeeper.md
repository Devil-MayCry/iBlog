---
title: 《从Paxos到zookeeper分布式一致性原理与实践》学习笔记
date: "2019-03-30"
description: ""
image: "/blog/paxos_to_zookeeper/bitcoin.jpeg"
---
 阅读《从Paxos到zookeeper》的一些笔记记录.
 
 虽然主要是讲Zookeeper使用的，但前几章对分布式体系和历史的介绍很赞
<!--more-->

# 第一章：分布式架构

* ACID:事务需要满足的原子性，一致性，隔离性，持久性
* 分布式事务的CAP和BASE理论
* CAP:  一致性，可用性，分区容错性，只能同时满足两个。但针对分布式系统，P是必须满足的，所以实在C和A之间寻找平衡
* BASE:是基本可用，软状态，最终一致性的简写。

# 

# 第二章: 一致性协议

* 2PC（两阶段提交）和3PC（三阶段提交），Paxos:都是为了解决分布式系统一致性的问题
* 当一个事务操作需要跨越多个分布式节点的时候，为了保持事物的ACID特性，就需要引入一个称为协调者（coordinator）的组件来统一调度所有的分布式节点的执行逻辑。这些被调度的分布式节点则被称为参与者（Participant）

### 2PC：

阶段一：提交事务请求

1. 事务询问
2. 执行事务，并将uodo和redo信息记入事务日志中
3. 各参与者向协调者反馈1的相应

阶段二：执行事务提交

如果所有参与者都是yes

1. 发送提交请求
2. 参与者执行提交
3. 反馈提交结果
4. 完成事务

如果一个参与者反馈no，或者等待超时无反馈，进行中断

1. 发送回滚请求
2. 事务回滚
3. 反馈事务回滚结果
4. 中断事务

2PC优点：

1. 强一致性
2. 原理简单，实现方便

2PC缺点：

1. 同步阻塞
2. 协调者出现问题，整个系统停滞
3. 异常时会有数据不一致
4. 总的来说，没有容错机制，任意一个节点失败都会导致整个事务失败

### 3PC：

三阶段提交将”提交事务请求“过程一分为二，形成了由CanCommit,PreCommit, doCommit三个阶段组成的事务处理协议

阶段一：CanCommit

1. 事务询问
2. 各参与者向协调者反馈事务询问的相应

阶段二：PreCommit

当所有都为yes

1. 发送预提交请求（PreCommit）,进入Prepared
2. 参与者接收到预提交后，执行事务操作，并将uodo和redo记录到日志
3. 参与者向协调者反馈执行相应ack，等待最终指令

当没有收到所有yes时

1. 协调者向所有参与者发送abort
2. 中断事务

阶段三：doCommit

两种情况

执行提交：

1. 如果协调者接收到所有参与者的ack，它将从”预提交“转换到”提交“，向所有的参与者发送doCommit
2. 事务提交
3. 参与者完成提交后，向协调者发送ack
4. 协调者收到所有ack后，完成事务

中断事务：

1. 协调者向所有参与者发送abort请求
2. 参与者利用undo信息执行回滚操作
3. 反馈事务回滚结果，向协调者发送ack
4. 中断事务

在阶段三，如果协调者出现问题或者协调者与参与者网络出现问题，无法收到abort请求，参与者都会在等待超时后，继续进行事务提交

3PC优点：降低阻塞范围，在单点故障后继续达成一致

缺点:在参与者收到preCommit消息后，如果网络出现分区，协调-参与之间通信异常，参与者继续进行事务操作，带来数据不一致。

#### Paxos算法

拜占庭将军问题： 在异步系统和不可靠通道上来达到一致性状态是不可能的。所以在对一致性的研究过程中，都假设信道可靠。

Paxos算法的前提也是，消息可能有不可预知的延迟，重复，或丢失，但不会被篡改

Paxos的目标是：不论发生任何异常，保证最终有一个提案会被选定，进程也最终能获取到被选定的提案

Paxos算法的核心：过半数投票

角色：Proposer， Acceptor,  Learner

#### 推导过程：

最终有一个提案被选定，当只有一个提案时也能选定-&gt;

推导一： p1 :一个Acceptor必须批准它收到的第一个提案

推导二：一个Acceptor必须能够批准不止一个提案

推导三：当一个具有Value值的提案被半数以上的Acceptor批准后，我们认为该Value被**选定**了，此时我们也认为该提案被**选定**了

由三可推导出-&gt;

推导四：允许多个提案被选定,但所有被选定的提案都用相同的value

推导-&gt;p2

如果编号M0，value为V0的提案被选定了，那么所有比编号M0高的，且被选定的提案，其Value的值也必须是V0

想要满足p2，可以通过满足p2a来实现：

p2a:

如果编号M0，value为V0的提案被选定了，那么所有比编号M0高的，且被Acceptor批准的提案，其Value的值也必须是V0

由于：一个提案可能会某个Acceptor未收到任何提案时就被选定，而当它收到一个编号更高的提案，并且必须通过（p1）时，就会与p2a矛盾，所以，必须对p2a进行强化：

p2b: 如果一个提案\[M0,V0\]被选定后，那之后的任何Proposer产生的编号更高的提案\(Mn&gt;M0\)，其value都为v0

所以，只要论证p2b成立即可

证明p2b过程（第二数学归纳法）：

证明p2b，可以通过证明以下结论满足：

**假设**编号在M0到Mn-1之间的提案，其value都是V0,   **证明**编号Mn的提案value也是v0

因为M0已经被选定了，意味着肯定存在一个由半数以上的Acceptor组成的集合C，C中的每个Acceptor都批准了该提案。

再结合假设，得知：

C中的每个Acceptor都批准了一个编号在M0到M1范围内的提案，并且每个编号在M0到Mn-1范围内的，被Acceptor批准的提案，其值都为V0

因为任何包含半数以上Acceptor的集合S都至少包含C中的一个成员，因此我们可以认为如果保持了下面p2c的不变性，那么编号Mn的提案的value也为V0

p2c: 对于任意的Mn和Vn，如果提案\[Mn,Vn\]被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：

* S中不存在任何批准过编号小于Mn提案的Acceptor

#### 

#### 算法陈述

阶段一：

1. Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的prepare请求
2. 如果一个Acceptor收到一个编号为Mn的Prepare请求。且编号Mn大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案

阶段二：

1. 如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对\[Mn,Vn\]提案的Accept请求给Acceptor。注意，Vn就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。
2. 如果Acceptor收到这个针对\[Mn,Vn\]提案的Accept请求，只要该Acceptor尚未对编号大于Mn的Prepare请求做出响应，它就可以通过这个提案

#### 提案的获取

Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的Learner（为避免单点故障，可以优化为一个集群\)。Learner之间通过消息通信相互告知。

#### 选取主Proposer保证算法活性

为了避免极端情况的”死循环“，必须选择一个主Proposer，规定只有主Proposer才能提出提案，这样只要主Proposer能够和半数以上的Acceptor通信，主Proposer提出一个编号更高的提案，就会被批准

_**（这段没看明白。如果是通用做法，那主Proposer是怎样和其他Proposer交换信息的？还是只是面对一些极端情况下的舍车保帅做法？）**_

# 第三章: Paxos的工程实践

### Chubby

chubby是一个面向松耦合分布式系统的锁服务。在众多应用场景中，最为典型的就是集群中服务器的Master选举

一个典型的Chubby集群，通常有5台服务器组成。这些副本服务器采用Paxos协议，通过投票的方式来选举产生一个获得过半投票的服务器作为Master。**chubby的所有工作，不管是写还是读，都是由master节点来完成。其他所有节点只做备份。客户端请求chubby时，通过DNS来找到master**

#### Paxos协议实现

集群中的每个服务器都维护着一份服务端数据库的副本，Master才能进行写操作，其他都是使用Paxos从master进行同步更新

\#个人理解：

这儿的同步和mysql的主从同步不同。

##### mysql：

从库生成两个线程，一个I/O线程，一个SQL线程；

i/o线程去请求主库 的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；

主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；

SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；

##### chubby

采用paxos来实现同步。master进行”Promise-&gt;Accept“阶段，写入本地日志，然后广播COMMIT消息给其他副本节点，并写入日志。如果其他副本没有收到COMMIT,则询问其他副本进行查询。



集群中的某台机器在宕机重启后，为了恢复状态机的状态，最简单的方法就是将已经记录的所有事务日志重新执行一遍

为了提高整个集群的性能，一小部分事务日志也可以通过从其他正常运行的副本上复制来进行获取，因此不需要实时地进行事务日志的flush

